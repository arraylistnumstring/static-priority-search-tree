# ?= defines variables if they have not already been defined
CXX ?= g++
CXXFLAGS := -std=c++20
# := is simple expansion (imperative-like definition)
# -ccbin specifies host compiler executable
NVCC := nvcc
NVCC_FLAGS := -ccbin $(CXX) $(CXXFLAGS) -rdc true

# COMMON_FLAGS for flags used at both compile-time and link-time
# -dlto: link-time optimisation of device code; requires usage at both compile and link time
COMMON_FLAGS := -dlto
# -dc: compile input files into object files containing relocatable device code; equivalent to -rdc true --compile
# Recursive assignment necessary for contained recursively assigned variables to be properly expanded, no matter the use location of such contained variables relative to their definitions
COMPILE_FLAGS = $(COMMON_FLAGS) $(INCLUDE) -dc
LINK_FLAGS = $(COMMON_FLAGS) $(LIBRARIES)

# Recursive assignment (essentially like call by name parameters, where the text assigned to the variable is substituted in its entirety each time it is called and evaluated only when used) so that all capital-letter variables can be grouped together, even though the following capital-letter variables depend on variables with lowercase names that are defined later
INCLUDE = $(addprefix -I ,$(include_dirs))
LIBRARIES = $(addprefix -l ,$(libraries))

# File suffixes of header and source files
header_suffixes := .h
depend_suffix := .d
object_suffix := .o
source_suffixes := .c .cpp .cu

# Set all directories that do not begin with a period to be an include directory (including symbolically linked directories)
# As maxdepth is a global option, the shell issues a complaint if it is not placed before non-global options
# Remove ./ prefix from directory names
include_dirs := $(patsubst ./%,%,$(shell find . -maxdepth 1 ! -name '.*' \( -type d -o -type l \)))
libraries := GL GLU
# Find all source files by finding all filenames ending in one of the suffixes found in source_suffixes that is not contained in a hidden folder
# Use of $\ ensures that no whitespace is added, as the escaped newline is evaluated first, becoming a space, then "$ " evaluates to the empty string, as the variable " " has no value (similar reasoning applies to not having a space before $\)
source_files := $(patsubst ./%,%,$\
					$(foreach source_suffix,$(source_suffixes),$\
						$(shell find . -name '*$(source_suffix)' ! -path './.*' -type f)$\
					)$\
				)

# Save prerequisites in generated makefiles so that they need not be computed every time, but only when the makefile does not already exist or the corresponding source file is updated
depend_files := $(foreach source_suffix,$(source_suffixes),$\
					$(patsubst %$(source_suffix),%$(depend_suffix),$\
						$(filter %$(source_suffix),$(source_files))$\
					)$\
				)
# Find all driver files (i.e. files that need to be compiled into executables) by picking out all source_files that have a main() function
# Use {} so that make is not confused by the open parenthesis in the regex given to grep and thus would not mistakenly think that the shell call has not been closed properly
driver_files := ${shell grep 'main[[:space:]]*(' $(source_files) -l}
# Replace source file suffixes with object_suffix to match requirements auto-generated by -MM flag of compiler
object_files := $(foreach source_suffix,$(source_suffixes),$\
					$(patsubst %$(source_suffix),%$(object_suffix),$\
						$(filter %$(source_suffix),$(source_files))$\
					)$\
				)
# Remove source file suffixes from names in driver_file to get executable names
# For each type of source file suffix, find the names in driver_files with that suffix and generate the corresponding executable name; then, notdir strips all files of their source directory names, placing executables in the top-level project folder
executables := $(notdir \
					$(foreach source_suffix,$(source_suffixes),$\
						$(patsubst %$(source_suffix),%,$(filter %$(source_suffix),$(driver_files)))$\
					)$\
				)

# As vpath is a directive, use this method of variable definition to parameterise the calling of vpath
# Use of define allows for newlines to be included in variable values (see section 6.8 of the GNU Make manual, Defining Multi-Line Variables)
# $(n) access the n-th parameter (1-indexed)
define vpath_func
	vpath $(1) $(2)
endef

# Add include_dirs to the search path of all source files (files with suffix found in source_suffixes) as well as all header files
# Use of eval allows for creation of non-constant Makefile syntax, including but not limited to targets, implicit or explicit rules, new make variables, etc.
# Use of call is necessary for vpath_func to be evaluated as a function with the parameters listed, rather than as a variable
$(foreach suffix_type,$(depend_suffix) $(header_suffixes) $(source_suffixes),$\
	$(eval $(call vpath_func,%$(suffix_type),$(include_dirs))))

.PHONY: all
all: $(executables)

# Prerequisites for dependency files; find the source file whose filename (minus the suffix) matches that of depend_file exactly
# All prerequisites for a single target are put together, so specifying prerequisites for a target multiple times does not overwrite previous values
$(foreach depend_file,$(depend_files),$\
	$(eval $(depend_file): \
		$(foreach source_suffix,$(source_suffixes),$\
			$(filter $(depend_file:$(depend_suffix)=$(source_suffix)),$(source_files))$\
		)$\
	)$\
)
# Double quotes allow for interpolation of content contained within (whereas single quotes preserve the literal value of everything they contain, including $,\, etc.); use either to preserve the presence of literal backslashes
# -MM: generate prerequisites for object file created from input source file; overridden by actual compilation into an object file if -o option is specified
# As -MM option automatically places object file target in current directory, prepend the directory of the source file to match the names specified in object_files
%$(depend_suffix):
	$(call gen-prereqs,'$(dir $<)$(shell $(NVCC) $(NVCC_FLAGS) $(COMPILE_FLAGS) -MM $<)')

define gen-prereqs
@# @ prefix in a recipe prevents echoing of that line (i.e. outputting the contents of a command before executing it)
@# Generate and place object file prerequisites in the associated source file's dependency file
@# Passing shell output into a make variable (here, $(1)), doesn't preserve newlines, so restore backslash-newline combos via sed
@# Square brackets necessary to prevent backslashes from interfering with parsing of capturing parentheses; sed supports literal newlines, but not the interpretation of \n as a newline character
echo $(1) | sed "s,\([\\]\)\s*,\1\\
\t,g" > $@

@# If source file prerequisite is a driver source file, add the object file prerequisites for the associated executable; additionally, as each executable depends on different object files, write rules and recipes for target executables in the corresponding dependency file
@# -n checks for the non-nullity of a string
@# By default, make evaluates each line of a recipe in a different shell (and the .ONESHELL variable forces all recipes to use a single shell per recipe throughout the makefile), so use shell newlines to force use of the same shell and thereby keep values of instantiated shell variables, while not causing unforseen consequences by modifying the globally effective variable .ONESHELL
@# Build executable in top-level directory
@# strip command is necessary because functions contained within evaluate to give a leading whitespace
if [ -n "$(filter $<,$(driver_files))" ]; \
then \
	echo >> $@; \
	executable=$(notdir $(@:$(depend_suffix)=)); \
	echo -n "$$executable: " >> $@; \
	prereq_objs=$(strip
					$(foreach suffix_type,$(source_suffixes),$\
						$(patsubst %$(suffix_type),%$(object_suffix),$\
							$(filter %$(suffix_type),$(1))$\
						)$\
					)$\
				); \
	echo $$prereq_objs >> $@; \
	echo "\t\$$(NVCC) \$$(NVCC_FLAGS) \$$(LINK_FLAGS) $$prereq_objs -o $$executable" >> $@; \
fi
endef


# For each object file, use as input file the prerequisite that has the same filename prefix as the target and has a source file suffix (this is because while object files are the result of compiling single source files, if any header has its own source file(s) that are thus part of this object file's prerequisites, that header's source file(s) should not be sent as input when compiling this object file)
# As vpath is only meant for searching for existing header and source files, generated files that are targets must be specified if they are found in some directory other than the top-level one
$(object_files):
	$(NVCC) $(NVCC_FLAGS) $(COMPILE_FLAGS) -o $@ \
		$(filter $(wildcard $(@:$(object_suffix)=)*),$\
			$(filter $(foreach source_suffix,$(source_suffixes),%$(source_suffix)),$^))


.PHONY: clean
clean:
	rm -f $(depend_files) $(executables) $(object_files)


# Only include dependency files if not running make clean (as such files would be generated because of the include directive just to be immediately removed afterwards by the recipe in target clean)
# Note that all commands in an included Makefile are run as if they were directly written in the current Makefile
# MAKECMDGOALS contains the goal specified on the command line when invoking make, e.g. make all has goal "all"
ifeq (,$(filter clean,$(MAKECMDGOALS)))
include $(depend_files)
endif
